<script>

  /* Question 1 - Solution */

  const parts = [ 'this', 'is', 'fun' ];

  console.log( parts.reduce( (fullString, part) => {

    return fullString + part;

  }, "" /* initial empty fullString */) );

  /* Question 2 - Solution */

  const myMap = (items, transformFn) => {

    return items.reduce( (mappedItems, item) => {

      mappedItems.push(transformFn(item));
      
      return mappedItems; /* will be the new mappedItems param for the next item */
    
    }, [] /* initial value of mappedItems param */);

  };

  const nums = [ 1,2,3,4,5 ];
  const doubleNums = myMap(nums, num => num * 2);

  console.log(nums);
  console.log(doubleNums);

  /* Question 3 - Solution */

  const myFilter = (items, predicateFn) => {

    return items.reduce( (filteredItems, item) => {

      if (predicateFn(item)) {
        filteredItems.push(item);
      }

      return filteredItems; /* will be the new filteredItems param for the next item */

    }, [] /* initial value of filteredItems param */);
  };

  const filteredNums = myFilter(nums, num => num > 3);

  console.log(nums);
  console.log(filteredNums);

  /* Question 4 - Solution */

  const myReduce = (items, itemFn, initialAccumulator) => {

    let accumulator = initialAccumulator;

    for (let x = 0; x < items.length; x++) {
      accumulator = itemFn(accumulator, items[x]);      
    }

    return accumulator;
  };

  console.log( myReduce(parts, (s, p) => s + p, '') );

</script>